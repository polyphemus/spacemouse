#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include <getopt.h>

#include "commands.h" /* MIN_DEVIATION and N_EVENTS definition */
#include "util.h"

#include "options.h"

#define VERSION_RET 128

static char const help_message[] = \
"Usage: spm [OPTIONS]\n"
"       spm <COMMAND> [OPTIONS]\n"
"       spm led [OPTIONS] (on | 1) | (off | 0)\n"
"       spm led [OPTIONS] (switch | !)\n"
"       spm event [OPTIONS] (--events <N> | --milliseconds <MILLISECONDS>)\n"
"       spm (-h | --help)\n"
"\n"
"Commands: (defaults to 'list' if no command is specified)\n"
"  list: Print device information of connected 3D/6DoF input devices\n"
"  led: Print or manipulate the LED state of connected 3D/6DoF input devices\n"
"  event: Print events generated by connected 3D/6DoF input devices\n"
"  raw: Print comprehensive info of raw events and device changes\n"
"\n"
"Options:\n"
"  -D, --devnode=DEV          regular expression (ERE) which devices'\n"
"                             devnode string must match\n"
"  -M, --manufacturer=MAN     regular expression (ERE) which devices'\n"
"                             manufacturer string must match\n"
"  -P, --product=PRO          regular expression (ERE) which devices'\n"
"                             product string must match\n"
"  -i, --ignore-case          case insensitive regex\n"
"  -h, --help                 display this help\n"
"      --version              display version information\n"
"\n"
"Additional options for event command:\n"
"  -g, --grab                 grab matched/all devices\n"
"  -d, --deviation=DEVIATION  minimum deviation on an motion axis needed\n"
"                             to register as an event\n"
"                             default is: " STR(MIN_DEVIATION) "\n"
"  -n, --events=N             number of consecutive events for which\n"
"                             deviaton must exceed minimum deviation before\n"
"                             printing an event to stdout\n"
"                             default is: " STR(N_EVENTS) "\n"
"  -m, --milliseconds=        millisecond period in which consecutive\n"
"               MILLISECONDS  events' deviaton must exceed minimum deviation\n"
"                             before printing an event to stdout";

int
parse_options(int argc, char **argv, options_t *options, cmd_t cmd)
{
  int c;

  int longindex = 0;
  char *optstring = cmd == EVENT_CMD ? "D:M:P:ihgd:n:m:" : "D:M:P:ih";
  struct option longopts[] = {
    /* event command specific options */
    { "grab", no_argument, NULL, 'g' },
    { "deviation", required_argument, NULL, 'd' },
    { "events", required_argument, NULL, 'n' },
    { "milliseconds", required_argument, NULL, 'm' },
    /* common options */
    { "devnode", required_argument, NULL, 'D' },
    { "manufacturer", required_argument, NULL, 'M' },
    { "product", required_argument, NULL, 'P' },
    { "ignore-case", no_argument, NULL, 'i' },
    { "help", no_argument, NULL, 'h' },
    { "version", no_argument, NULL, VERSION_RET },
    { 0, 0, 0, 0 }
  };

  if (cmd != EVENT_CMD)
    longindex = 4;
  if (cmd != NO_CMD)
    optind = 2;

  while ((c = getopt_long(argc, argv, optstring, longopts, &longindex))
         != -1) {
    int tmp;
    switch (c) {
      case 'D':
        options->dev_re = optarg;
        break;

      case 'M':
        options->man_re = optarg;
        break;

      case 'P':
        options->pro_re = optarg;
        break;

      case 'i':
        options->re_ignore_case = true;
        break;

      case 'g':
        options->grab = true;
        break;

      case 'd':
        if ((tmp = atoi(optarg)) < 1)
          fail("%s: '-d'/'--deviation' option's argument needs to be a valid "
               "positive integer\n", argv[0]);
        else
          options->deviation = tmp;
        break;

      case 'n':
        if ((tmp = atoi(optarg)) < 1)
          fail("%s: '-n'/'--events' option's argument needs to be a valid "
               "positive integer\n", argv[0]);
        else
          options->events = tmp;
        break;

      case 'm':
        if ((tmp = atoi(optarg)) < 1)
          fail("%s: '-m'/'--milliseconds' option's argument needs to be a "
               "valid positive integer\n", argv[0]);
        else
          options->milliseconds = tmp;
        break;

      case 'h':
        puts(help_message);
      case '?':
        exit(EXIT_FAILURE);
        break;

      case VERSION_RET:
        puts("spm version " STR(VERSION));

        exit(EXIT_SUCCESS);
        break;
    }
  }

  if (options->events != 0 && options->milliseconds != 0)
    fail("%s: options '-n'/--events' and '-m'/--milliseconds' are mutually "
         "exclusive\n", argv[0]);

  /* return number of arguments consumed */
  return optind;
}
