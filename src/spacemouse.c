/*
Copyright (c) 2013 Rolf Morel

This program is part of spacemouse-utils.

spacemouse-utils - a collection of simple utilies for 3D/6DoF input devices.

spacemouse-utils is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

spacemouse-utils is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with spacemouse-utils.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <sys/types.h>
#include <regex.h>
#include <getopt.h>

#include <poll.h>

#include <libspacemouse.h>

#define STR_HELPER(x) #x
#define STR(x) STR_HELPER(x)

#define ARRLEN(x) (sizeof x / sizeof *x)

// FreeBSD sysexits.h: An error occurred while doing I/O on some file.
#define EX_IOERR 74

#define MIN_DEVIATION 256
#define N_EVENTS 16

enum {
  NO_CMD = 0,
  LIST_CMD = 1,
  LED_CMD = 1 << 1,
  EVENT_CMD = 1 << 2
};

bool multi_call = false, grab_opt = false;

int command = NO_CMD;
int regex_mask = REG_EXTENDED | REG_NOSUB;
int deviation_opt = MIN_DEVIATION, events_opt = 0, millis_opt = 0;
char const *dev_opt = NULL, *man_opt = NULL, *pro_opt = NULL;

#define COMMON_LONG_OPTIONS \
    { "devnode", required_argument, NULL, 'd' }, \
    { "manufacturer", required_argument, NULL, 'm' }, \
    { "product", required_argument, NULL, 'p' }, \
    { "ignore-case", no_argument, NULL, 'i' }, \
    { "help", no_argument, NULL, 'h' },

char const *opt_str_no_cmd = "d:m:p:ih";
struct option const long_options_no_cmd[] = {
  COMMON_LONG_OPTIONS
  { 0, 0, 0, 0 }
};

char const help_no_cmd[] = \
"Usage: spacemouse [OPTIONS]\n"
"       spacemouse <COMMAND> [OPTIONS]\n"
"       spacemouse led [OPTIONS] (on | 1) | (off | 0)\n"
"       spacemouse led [OPTIONS] (switch | !)\n"
"       spacemouse event [OPTIONS] (--events <N> | --millis <MILLISECONDS>)\n"
"       spacemouse (-h | --help)\n"
"\n"
"Commands: (defaults to 'list' if no command is specified)\n"
"  list: Print device information of connected 3D/6DoF input devices\n"
"  led: Print or manipulate the LED state of connected 3D/6DoF input devices\n"
"  event: Print events generated by connected 3D/6DoF input devices\n"
"\n";

char const help_common_opts[] = \
"Options:\n"
"  -d, --devnode=DEV          regular expression (ERE) which devices'\n"
"                             devnode string must match\n"
"  -m, --manufacturer=MAN     regular expression (ERE) which devices'\n"
"                             manufacturer string must match\n"
"  -p, --product=PRO          regular expression (ERE) which devices'\n"
"                             product string must match\n"
"  -i, --ignore-case          makes regular expression matching case\n"
"                             insensitive\n";

char const help_event_opts[] = \
"  -g, --grab                 grab matched/all devices\n"
"  -D, --deviation=DEVIATION  minimum deviation on an motion axis needed\n"
"                             to register as an event\n"
"                             default is: " STR(MIN_DEVIATION) "\n"
"  -n, --events=N             number of consecutive events for which\n"
"                             deviaton must exceed minimum deviation before\n"
"                             printing an event to stdout\n"
"                             default is: " STR(N_EVENTS) "\n"
"  -M, --millis=MILLISECONDS  millisecond period in which consecutive\n"
"                             events' deviaton must exceed minimum deviation\n"
"                             before printing an event to stdout\n";

char const help_common_opts_end[] = \
"  -h, --help                 display this help\n";

int run_regex(char const *regex, char const *string, int comp_mask)
{
  regex_t preg;
  int ret;

  if (regcomp(&preg, regex, comp_mask) != 0)
    return -1;

  ret = regexec(&preg, string, 0, NULL, 0);

  regfree(&preg);

  return ret;
}

int match_device(struct spacemouse *mouse)
{
  int match = 0;
  char const *opts[] = { dev_opt, man_opt, pro_opt };
  char const *members[] = { spacemouse_device_get_devnode(mouse),
                            spacemouse_device_get_manufacturer(mouse),
                            spacemouse_device_get_product(mouse) };

  for (int n = 0; n < 3; n++) {
    if (opts[n] != NULL) {
      int regex_success = run_regex(opts[n], members[n], regex_mask);
      if (regex_success == -1) {
        return -1;
      } else if (regex_success == 1)
        match++;
    }
  }
  return !match;
}

int parse_substr_strs(char const *substr, char const **str_arr, int *val_arr) {
  int ret = 0, i = -1, sub_len = strlen(substr);

  while (str_arr[++i] != NULL)
    if (strncmp(substr, str_arr[i], sub_len) == 0) {
      if (ret > 0)
        ret = -2; // there already is a match, set err with number of matches
      else if (ret < 0)
        ret -= 1; // for every subsequent match increase err return count
      else
        ret = val_arr[i];
    } else
      val_arr[i] = 0;

  return ret;
}

int parse_arguments(int argc, char **argv, char const *opt_str,
                    struct option const *long_options)
{
  int c;

  if (!multi_call && command != NO_CMD)
    optind = 2;

  while ((c = getopt_long(argc, argv, opt_str, long_options, NULL)) != -1) {
    int tmp;
    switch (c) {
      case 'd':
        dev_opt = optarg;
        break;

      case 'm':
        man_opt = optarg;
        break;

      case 'p':
        pro_opt = optarg;
        break;

      case 'i':
        regex_mask |= REG_ICASE;
        break;

      case 'g':
        grab_opt = true;
        break;

      case 'D':
        if ((tmp = atoi(optarg)) < 1) {
          fprintf(stderr, "%s: option '--deviation' needs to be a valid "
                  "positive integer\n", *argv);
          return EXIT_FAILURE;
        } else
          deviation_opt = tmp;
        break;

      case 'n':
        if ((tmp = atoi(optarg)) < 1) {
          fprintf(stderr, "%s: option '--events' needs to be a valid "
                  "positive integer\n", *argv);
          return EXIT_FAILURE;
        } else
          events_opt = tmp;
        break;

      case 'M':
        if ((tmp = atoi(optarg)) < 1) {
          fprintf(stderr, "%s: option '--millis' needs to be a valid "
                  "positive integer, in milliseconds\n", *argv);
          return EXIT_FAILURE;
        } else
          millis_opt = tmp;
        break;

      case 'h':
        return -1; // display help and exit program successfully

      case '?':
        return EXIT_FAILURE;
        break;
    }
  }

  if (events_opt != 0 && millis_opt != 0) {
    fprintf(stderr, "%s: options '--events' and '--millis' are mutually "
            "exclusive\n", *argv);
    return EXIT_FAILURE;
  } else if (events_opt == 0)
    events_opt = N_EVENTS;

  return 0;
}

int run_list_command(int argc, char **argv)
{
  {
    char const help_list_cmd[] = \
"Usage: spacemouse-list [OPTIONS]\n"
"       spacemouse-list (-h | --help)\n"
"Print device information of connected 3D/6DoF input devices.\n"
"\n";

    int status = parse_arguments(argc, argv, opt_str_no_cmd,
                                 long_options_no_cmd);
    if (status == -1) {
      if (multi_call)
        printf(help_list_cmd);
      else
        printf(help_no_cmd);

      printf(help_common_opts);
      if (!multi_call)
        printf(help_event_opts);
      printf(help_common_opts_end);

      return EXIT_SUCCESS;
    } else if (status != 0)
      return status;
  }

  if (optind != argc) {
    fprintf(stderr, "%s: invalid non-command or non-option argument(s), see "
            "'-h' for help\n", *argv);
    return EXIT_FAILURE;
  }

  struct spacemouse *iter;
  int match, err = spacemouse_device_list(&iter, 1);
  /* TODO: add error check */
  spacemouse_device_list_foreach(iter, iter)
    if ((match = match_device(iter)) == -1) {
      fprintf(stderr, "%s: failed to use regex, please use valid ERE\n",
              *argv);
      return EXIT_FAILURE;
    } else if (match) {
      printf("devnode: %s\n", spacemouse_device_get_devnode(iter));
      printf("manufacturer: %s\n", spacemouse_device_get_manufacturer(iter));
      printf("product: %s\n\n", spacemouse_device_get_product(iter));
    }

  return EXIT_SUCCESS;
}

int run_led_command(int argc, char **argv)
{
  enum {
    LED_NONE = 0,
    LED_OFF,
    LED_ON,
    LED_SWITCH
  };

  int state_arg = LED_NONE;

  {
    char const help_led_cmd[] = \
"Usage: spacemouse-led [OPTIONS]\n"
"       spacemouse-led [OPTIONS] (on | 1) | (off | 0)\n"
"       spacemouse-led [OPTIONS] (switch | !)\n"
"       spacemouse-led (-h | --help)\n"
"Print or manipulate the LED state of connected 3D/6DoF input devices.\n"
"\n";

    int status = parse_arguments(argc, argv, opt_str_no_cmd,
                                 long_options_no_cmd);
    if (status == -1) {
      if (multi_call)
        printf(help_led_cmd);
      else
        printf(help_no_cmd);

      printf(help_common_opts);
      if (!multi_call)
        printf(help_event_opts);
      printf(help_common_opts_end);

      return EXIT_SUCCESS;
    } else if (status != 0)
      return status;
  }

  if (optind == (argc - 1)) {
    char const *cmd_strs[] = { "on", "1", "off", "0", "switch", "!", NULL };
    int cmd_vals[] = { LED_ON, LED_ON, LED_OFF, LED_OFF, LED_SWITCH,
                       LED_SWITCH, 0};

    for (char *ptr = argv[optind]; *ptr != 0; ptr++)
      *ptr = tolower(*ptr);

    state_arg = parse_substr_strs(argv[optind], cmd_strs, cmd_vals);

    if (state_arg <= 0) {
      fprintf(stderr, "%s: non-option argument '%s' is %s", *argv,
              argv[optind], state_arg == 0 ? "invalid, see '-h' for help\n":
              "ambiguous; possibilities:");
      if (state_arg < 0) {
        for (int i = 0; i < ARRLEN(cmd_vals); i++)
          if (cmd_vals[i] > 0 && cmd_strs[i] != NULL)
            printf(" '%s'", cmd_strs[i]);
        puts("");
      }
      return EXIT_FAILURE;
    }
  } else if (optind != argc) {
    fprintf(stderr, "%s: expected zero or one non-option arguments, see "
                "'-h' for help\n", *argv);
    return EXIT_FAILURE;
  }

  struct spacemouse *iter;
  int match, err = spacemouse_device_list(&iter, 1);
  /* TODO: add error check */
  spacemouse_device_list_foreach(iter, iter) {
    if ((match = match_device(iter)) == -1) {
      fprintf(stderr, "%s: failed to use regex, please use valid ERE\n",
              *argv);
      return EXIT_FAILURE;
    } else if (match) {
      int led_state = -1;

      if ((err = spacemouse_device_open(iter)) < 0) {
        fprintf(stderr, "%s: failed to open device '%s': %s\n", *argv,
                spacemouse_device_get_devnode(iter), strerror(-err));
        return EXIT_FAILURE;
      }

      if (state_arg == LED_NONE || state_arg == LED_SWITCH) {
        if ((led_state = spacemouse_device_get_led(iter)) < 0) {
          fprintf(stderr, "%s: failed to get led state for '%s': %s\n", *argv,
                  spacemouse_device_get_devnode(iter), strerror(-led_state));
          return EXIT_FAILURE;
        }
      }

      if (state_arg == LED_NONE) {
        printf("%s: %s\n", spacemouse_device_get_devnode(iter),
               led_state ? "on": "off");
      } else {
        int state = state_arg == LED_SWITCH ? !led_state : state_arg - 1;

        if ((err = spacemouse_device_set_led(iter, state)) < 0) {
          fprintf(stderr, "%s: failed to set led state for '%s': %s\n", *argv,
                  spacemouse_device_get_devnode(iter), strerror(-err));
          return EXIT_FAILURE;
        }
        if (state_arg == LED_SWITCH) {
          printf("%s: switched %s\n", spacemouse_device_get_devnode(iter),
                 state ? "on": "off");
        }
      }

      spacemouse_device_close(iter);
    }
  }

  return EXIT_SUCCESS;
}

int run_event_command(int argc, char **argv)
{
  struct axis_event {
    unsigned int pos;
    unsigned int neg;
    char const * pos_str;
    char const * neg_str;
  };

  {
    char const *opt_str_event_cmd = "d:m:p:igD:n:M:h";
    struct option const long_options_event_cmd[] = {
      COMMON_LONG_OPTIONS
      { "grab", no_argument, NULL, 'g'},
      { "deviation", required_argument, NULL, 'D' },
      { "events", required_argument, NULL, 'n' },
      { "millis", required_argument, NULL, 'M' },
      { 0, 0, 0, 0 }
    };

    char const help_event_cmd[] = \
"Usage: spacemouse-event [OPTIONS]\n"
"       spacemouse-event [OPTIONS] (--events <N> | --millis <MILLISECONDS>)\n"
"       spacemouse-event (-h | --help)\n"
"Print events generated by connected 3D/6DoF input devices.\n"
"\n";

    int status = parse_arguments(argc, argv, opt_str_event_cmd,
                                 long_options_event_cmd);
    if (status == -1) {
      if (multi_call)
        printf(help_event_cmd);
      else
        printf(help_no_cmd);

      printf(help_common_opts);
      printf(help_event_opts);
      printf(help_common_opts_end);

      return EXIT_SUCCESS;
    } else if (status != 0)
      return status;
  }

  if (optind != argc) {
    fprintf(stderr, "%s: invalid non-command or non-option argument(s), see "
            "'-h' for help\n", *argv);
    return EXIT_FAILURE;
  }

#ifndef AXIS_MAP_SPACENAVD
  struct axis_event axis_map[] = { { 0, 0, "right", "left" },
                                   { 0, 0, "back", "forward" },
                                   { 0, 0, "down", "up" },
                                   { 0, 0, "pitch back", "pitch forward" },
                                   { 0, 0, "roll left", "roll right" },
                                   { 0, 0, "yaw right", "yaw left" },
                                  };
#else
  struct axis_event axis_map[] = { { 0, 0, "right", "left" },
                                   { 0, 0, "up", "down" },
                                   { 0, 0, "forward", "back" },
                                   { 0, 0, "pitch back", "pitch forward" },
                                   { 0, 0, "yaw left", "yaw right" },
                                   { 0, 0, "roll right", "roll left" },
                                  };
#endif

  int match, err, monitor_fd = spacemouse_monitor_open();
  struct spacemouse *iter;

  err = spacemouse_device_list(&iter, 1);
  /* TODO: add error check */
  spacemouse_device_list_foreach(iter, iter) {
    if ((match = match_device(iter)) == -1) {
      fprintf(stderr, "%s: failed to use regex, please use valid ERE\n",
              *argv);
      return EXIT_FAILURE;
    } else if (match) {
      if ((err = spacemouse_device_open(iter)) < 0) {
        fprintf(stderr, "%s: failed to open device '%s': %s\n", *argv,
                spacemouse_device_get_devnode(iter), strerror(-err));
        return EXIT_FAILURE;
      }

      if (grab_opt && (err = spacemouse_device_set_grab(iter, 1)) < 0) {
        fprintf(stderr, "%s: failed to grab device '%s': %s\n", *argv,
                spacemouse_device_get_devnode(iter), strerror(-err));
        return EXIT_FAILURE;
      }
    }
  }

  /* If piped to another program, that program will probably want to parse
   * the output by line.
   */
  setvbuf(stdout, NULL, _IOLBF, 0);

  while(true) {
    int mouse_fd, err, fds_idx = 0;

    err = spacemouse_device_list(&iter, 0);
    /* TODO: add error check */
    spacemouse_device_list_foreach(iter, iter)
      if (spacemouse_device_get_fd(iter) > -1)
        fds_idx++;

    struct pollfd fds[fds_idx + 1];
    fds_idx = 0;

    fds[fds_idx].fd = STDOUT_FILENO;
    fds[fds_idx++].events = POLLERR;

    fds[fds_idx].fd = monitor_fd;
    fds[fds_idx++].events = POLLIN;

    err = spacemouse_device_list(&iter, 0);
    /* TODO: add error check */
    spacemouse_device_list_foreach(iter, iter)
      if ((mouse_fd = spacemouse_device_get_fd(iter)) > -1) {
        fds[fds_idx].fd = mouse_fd;
        fds[fds_idx++].events = POLLIN;
      }

    poll(fds, fds_idx, -1);

    err = spacemouse_device_list(&iter, 0);
    /* TODO: add error check */

    for (int n = 0; n < fds_idx; n++) {
      if (fds[n].revents == 0)
        continue;

      if (fds[n].fd == STDOUT_FILENO && fds[n].revents & POLLERR)
        return EX_IOERR;
      else if (fds[n].fd == monitor_fd) {
        struct spacemouse *mon_mouse;
        int action = spacemouse_monitor(&mon_mouse);

        if (action == SPACEMOUSE_ACTION_ADD) {
          if (match_device(mon_mouse)) {
            if ((err = spacemouse_device_open(iter)) < 0) {
              fprintf(stderr, "%s: failed to open device '%s': %s\n", *argv,
                      spacemouse_device_get_devnode(mon_mouse),
                      strerror(-err));
              return EXIT_FAILURE;
            }

            if (grab_opt && (err = spacemouse_device_set_grab(mon_mouse, 1))
                < 0) {
              fprintf(stderr, "%s: failed to grab device '%s': %s\n", *argv,
                      spacemouse_device_get_devnode(mon_mouse),
                      strerror(-err));
              return EXIT_FAILURE;
            }

            printf("device: %s %s %s connect\n",
                   spacemouse_device_get_devnode(mon_mouse),
                   spacemouse_device_get_manufacturer(mon_mouse),
                   spacemouse_device_get_product(mon_mouse));
          }
        } else if (action == SPACEMOUSE_ACTION_REMOVE) {
          if (spacemouse_device_get_fd(mon_mouse) > -1) {
            printf("device: %s %s %s disconnect\n",
                   spacemouse_device_get_devnode(mon_mouse),
                   spacemouse_device_get_manufacturer(mon_mouse),
                   spacemouse_device_get_product(mon_mouse));

            if (grab_opt)
              spacemouse_device_set_grab(mon_mouse, 0);

            spacemouse_device_close(mon_mouse);
          }
        }

      } else {
        spacemouse_device_list_foreach(iter, iter) {
          mouse_fd = spacemouse_device_get_fd(iter);
          if (mouse_fd > -1 && fds[n].fd == mouse_fd) {
            spacemouse_event_t mouse_event = { 0 };
            int status = spacemouse_device_read_event(iter, &mouse_event);

            if (status == -1)
              spacemouse_device_close(iter);
            else if (status == SPACEMOUSE_READ_SUCCESS) {
              if (mouse_event.type == SPACEMOUSE_EVENT_MOTION) {
                int *int_ptr = &mouse_event.motion.x;
                for (int i = 0; i < 6; i++) {
                  unsigned int *axis_pol = NULL;
                  char const *axis_str = NULL;

                  if (int_ptr[i] > deviation_opt) {
                    axis_pol = &axis_map[i].pos;
                    axis_str = axis_map[i].pos_str;
                  } else
                    axis_map[i].pos = 0;

                  if (int_ptr[i] < (-1 * deviation_opt)) {
                    axis_pol = &axis_map[i].neg;
                    axis_str = axis_map[i].neg_str;
                  } else
                    axis_map[i].neg = 0;

                  if (axis_pol != NULL) {
                    if (millis_opt != 0) {
                      *axis_pol += mouse_event.motion.period;
                      if (*axis_pol > millis_opt) {
                        *axis_pol = *axis_pol % millis_opt;
                        printf("motion: %s\n", axis_str);
                      }
                    } else {
                      *axis_pol += 1;
                      if ((*axis_pol % events_opt) == 0)
                        printf("motion: %s\n", axis_str);
                    }
                  }
                }
              } else if (mouse_event.type == SPACEMOUSE_EVENT_BUTTON)
                printf("button: %d %s\n", mouse_event.button.bnum,
                       mouse_event.button.press ? "press" : "release");
              else if (mouse_event.type == SPACEMOUSE_EVENT_LED)
                printf("led: %s\n", mouse_event.led.state ? "on" : "off");
            }
          break;
          }
        }
      }
    }
  }

  return EXIT_SUCCESS;
}

int main(int argc, char **argv)
{
  {
    char const *exe_strs[] = { "spacemouse-list", "spacemouse-led",
                               "spacemouse-event", NULL };
    int exe_vals[] = { LIST_CMD, LED_CMD, EVENT_CMD, 0 };
    int i = -1, arg_len = strlen(*argv);

    while (exe_strs[++i] != NULL) {
      int exe_len = strlen(exe_strs[i]);
      if (arg_len >= exe_len &&
          strcmp(*argv + (arg_len - exe_len), exe_strs[i]) == 0) {
        command = exe_vals[i];
        multi_call = true;
      }
    }

    if (!multi_call && argc >= 2) {
      char const *cmd_strs[] = { "list", "ls", "led", "event", NULL };
      int cmd_vals[] = { LIST_CMD, LIST_CMD, LED_CMD, EVENT_CMD, 0 };

      int cmd = parse_substr_strs(argv[1], cmd_strs, cmd_vals);

      if (cmd < 0) {
        fprintf(stderr, "%s: command '%s' is ambiguous; possibilities:", *argv,
                argv[1]);
        for (int i = 0; i < ARRLEN(cmd_vals); i++)
          if (cmd_vals[i] > 0 && cmd_strs[i] != NULL)
            printf(" '%s'", cmd_strs[i]);
        puts("");
        return 1;
      } else if (cmd != 0)
        command = cmd;
    }
  }

  if (command == LED_CMD)
    return run_led_command(argc, argv);
  else if (command == EVENT_CMD)
    return run_event_command(argc, argv);
  else
    return run_list_command(argc, argv);
}
